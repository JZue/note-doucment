

#### 脏写

**针对未提交数据**

```
【定义】当两个事务同时尝试去更新某一条数据记录时，就肯定会存在一个先一个后。而当事务A更新时，事务A还没提交，事务B就也过来进行更新，覆盖了事务A提交的更新数据，这就是脏写。

【注意点】文上提到的4种隔离级别下，都不存在脏写情况。因为在这些隔离级别下，当两个事务A和B尝试去更新同一条数据时，假定A先更新数据，会对更新的数据行记录加上排他锁(也叫写锁，悲观锁)，除非事务A提交或终止从而释放排他锁，否则事务B都是无法更新数据的。（设计数据密集型应用只是说读提交隔离级别一定可以杜绝脏写问题，并未提到读未提交隔离级别，经过实践，读未提交下事务B的更新操作也是需要等待事务A的排他锁释放，才得以执行）

基于这一点,出现了很经典的一条SQL解决超卖问题的方案：
update tableName set count=count - #buy_num# where id = #id# and count >= #buy_num#;

【脏写会带来什么问题呢？】脏写是会导致更新丢失的一种情形。
什么是更新丢失？
当多个事务并发写同一数据时，先执行的事务所写的数据会被后写的覆盖，这也就是更新丢失。前面的脏写情形，就属于会导致更新丢失问题的一种情形。
除了这个，更新丢失主要发生在read-modify-write类型的事务当中：就是要先查询数据，然后计算新的数据，最后写回新的数据。
```



#### 脏读

**针对未提交数据**

```
【定义】 一个事务读取了另个事务未提交的数据，这个数据是有可能回滚的。即这个事物读取的数据是不正确的。

【注意点】在读未提交(Read Uncommitted)隔离级别下，是会出现脏读的。

        仔细体会读未提交(Read Uncommitted)隔离级别的命名--读取事务还未提交的数据，就会发现说的就是脏读。

【脏读会导致什么问题呢？】

1. 给用户带来数据混乱的感觉。
例如在一个多对象的事务A里，A需要生成一条邮件发送记录，同时需要在用户未读取邮件的计数里+1，这里涉及两张表的业务情形，就是对多对象的诠释。如果事务A insert邮件发送记录时（还没执行计数+1这个后面的操作），就被事务B查询了，可事务B此时看到的邮件计数还是+1之前的，这样就会导致事务B看到的未读取邮件条数与计数数据不一致。

2. 让用户看到根本不存在的数据。
事务A读取到事务B未提交的数据，然后事务B回滚数据
```

#### 不可重复读

**针对其他提交前后，读取数据本身的对比**

```
在数据库访问中，1个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交引起的。即这个事物在读的过程中被修改了。
```

#### 幻读

**针对其他提交前后，读取数据条数的对比**

```
当个事物对整个table进修改之后，第个事物向表中插了数据，此时第个事物发现了新插的没有修改的数据，好像发了幻觉样。
```



参考文章：https://www.codeprj.com/blog/9aa8501.html