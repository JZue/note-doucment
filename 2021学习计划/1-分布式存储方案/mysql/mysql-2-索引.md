### 什么是索引？

索引是一种能帮助 MySQL 提高查询效率的数据结构

### 索引分别有哪些优点和缺点？

索引的优点如下：

```
- 快速访问数据表中的特定信息，提高检索速度。
- 创建唯一性索引，保证数据表中每一行数据的唯一性。
- 加速表与表之间的连接。
- 使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。


```

索引的缺点：

```
- 虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；
- 建立索引会占用磁盘文件的索引文件。
```

使用索引注意事项：

```
- 使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；

- 索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；

- like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like "%aaa%" 不会使用索引，而like "aaa%"可以使用索引；

- 查询的字段或者条件字段可以不与索引字段全部一致，但开头必须一致，且中间不能隔断。例如：abc->abc/ab/a

- 在索引列上做任何操作(计算、 函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描

  - 	错误的例子：select * from test where id-1=9;

    	 正确的例子：select * from test where id=10;

- 尽量使用覆盖索引（只访问索引的查询（查询列和索引列保持一致）），减少select*

- 当索引出现范围条件后，其后边的索引列将不能被使用

- MySQL在使用不等于(<>或!=)时无法使用索引，会导致全表扫描

- is null和is not null也无法使用索引

- or 在特定情况下也会引起索引失效(https://blog.csdn.net/wenniuwuren/article/details/89472136)

- 数据类型错误也会导致索引失效。例如表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给mysql,这样会导致索引失效.

#### 两表

当使用left join时，左表是驱动表，右表是被驱动表，  右表建索引更好-》因为左连接左表一定会全表扫描的，右表部分扫描

当使用right join时，右表时驱动表，左表是被驱动表，  左表建索引更好-》因为右连接右表一定会全表扫描，左表部分扫描

当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。  大表使用索引

总结：多表连接时永远是被驱动表的索引起作用

#### 三表

- 小表驱动大表结果集
- 优先优化内存循环
- 保证join语句中被驱动表上join条件字段已经被索引
- 当无法保证被驱动表的join条件字段被索引内存资源充足的前提下，不要太吝啬JoinBuffer的设置


以下 SQL 有什么问题？该如何优化？

select * from t where f/2=100;
该 SQL 会导致引擎放弃索引而全表扫描，尽量避免在索引列上计算。可改为：

select * from t where f=100*2;
```



### 为什么 MySQL 官方建议使用自增主键作为表的主键？

```
索引的物理存储结构：https://blog.csdn.net/qq_37286668/article/details/112176944


mysql (注意本文讲的 mysql 默认为InnoDB 引擎)底层数据结构是 B+ 树，所谓的索引其实就是一颗 B+ 树，一个表有多少个索引就会有多少颗 B+ 树，mysql 中的数据都是按顺序保存在 B+ 树上的(所以说索引本身是有序的)。

然后 mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。

如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。

如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。

当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。

这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的。

其实对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小。
```

```
优点：
- 性能好
- 减少页分裂
缺点：
- 数据量大，可能会超出取值范围
- 分库分表会有问题(一般设定步长，或者自研自增id算法)
 
 
```

### 索引有几种类型？分别如何创建？

MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：

- 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；
- 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，一个唯一索引可以包含一列或者多列，比如身份证号码、卡号等都可以作为唯一索引；
- 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；
- 全文索引：让搜索关键词更高效的一种索引。

按照物理分类，索引可分为：

- 聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；
- 非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。

各种索引的创建脚本如下：

```sql
-- 创建主键索引
alter table t add primary key add (`id`);
-- 创建唯一索引
alter table t add unique (`username`);
-- 创建普通索引
alter table t add index index_name (`username`);
-- 创建全文索引
alter table t add fulltext (`username`);
```



### 主索引和唯一索引有什么区别？

- 主索引不能重复且不能为空，唯一索引不能重复，但可以为空；
- 一张表只能有一个主索引，但可以有多个唯一索引；
- 主索引的查询性能要高于唯一索引。

### 什么叫回表查询？

普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。

```
因为普通索引的查询会多执行一次检索操作。比如主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。
```



### 如何查询一张表的所有索引？

`SHOW INDEX FROM T` 查询表 T 所有索引。



### MySQL 最多可以创建多少个索引列？

MySQL 中最多可以创建 16 个索引列。



### 如何让 like %abc 走索引查询？

我们知道如果要让 like 查询要走索引，查询字符不能以通配符（%）开始，如果要让 like %abc 也走索引，可以使用 REVERSE() 函数来创建一个函数索引，查询脚本如下：

> select * from t where reverse(f) like reverse('%abc');

### MySQL 联合索引应该注意什么？

联合索引又叫复合索引，MySQL 中的联合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。



### 联合索引的作用是什么？

联合索引的作用如下：

- 用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了 key(a)、key(a,b)、key(a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；
- 覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：`select a,b,c from table where a=1 and b = 1` ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；
- 索引列越多，通过索引筛选出的数据越少。

### 什么是最左匹配原则？它的生效原则有哪些？

最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（>、<、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：

- where a=1 只使用了索引 a；
- where a=1 and b=2 只使用了索引 a,b；
- where a=1 and b=2 and c=3 使用a,b,c；
- where b=1 or where c=1 不使用索引；
- where a=1 and c=3 只使用了索引 a；
- where a=3 and b like 'xx%' and c=3 只使用了索引 a,b。

### 以下语句会走索引么？

```sql
select * from t where year(date)>2018;

```

不会，因为在索引列上涉及到了运算。



### 能否给手机号的前 6 位创建索引？如何创建？

可以，创建方式有两种：

- alter table t add index index_phone(phone(6));
- create index index_phone on t(phone(6));

### 什么是前缀索引？

前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。

### 为什么要用前缀索引？

前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。

### 什么是页？

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。主存和磁盘以页为单位交换数据。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次磁盘 IO 就可以完全载入。

### 索引的常见存储算法有哪些？

- 哈希存储法：以 key、value 方式存储，把值存入数组中使用哈希值确认数据的位置，如果发生哈希冲突，使用链表存储数据；
- 有序数组存储法：按顺序存储，优点是可以使用二分法快速找到数据，缺点是更新效率，适合静态数据存储；
- 搜索树：以树的方式进行存储，查询性能好，更新速度快。

### InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？

因为 B 树、Hash、红黑树或二叉树存在以下问题：

- B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；
  - https://blog.csdn.net/ligupeng7929/article/details/79529072
- Hash：虽然可以快速定位，但是没有顺序，**希表这种结构适用于只有等值查询的场景**；对于区间查询只能全表扫描，复杂度高
- 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；
- 红黑树：树的高度随着数据量增加而增加，IO 代价高。
- 有序数组：**有序数组在等值查询和范围查询场景中的性能就都非常优秀**（等值查询：二分查找，范围也很快），有序数组索引只适用于静态存储引擎

### 为什么 InnoDB 要使用 B+ 树来存储索引？

B+Tree 中的 B 是 Balance，是平衡的意思，它在经典 B Tree 的基础上进行了优化，增加了顺序访问指针，在B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree，这样就提高了区间访问性能：如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率（无需返回上层父节点重复遍历查找减少 IO 操作）。

索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，这样的话，索引查找过程中就要产生磁盘 IO 消耗，相对于内存存取，IO 存取的消耗要高几个数量级，所以索引的结构组织要尽量减少查找过程中磁盘 IO 的存取次数，从而提升索引效率。 综合所述，InnDB 只有采取 B+ 树的数据结构存储索引，才能提供数据库整体的操作性能。

### 唯一索引和普通索引哪个性能更好？

- 对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；
- 对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。

### 优化器选择查询索引的影响因素有哪些？

优化器的目的是使用最小的代价选择最优的执行方案，影响优化器选择索引的因素如下：

- 扫描行数，扫描的行数越少，执行代价就越少，执行效率就会越高；
- 是否使用了临时表；
- 是否排序。

### MySQL 是如何判断索引不重复记录数(索引基数)

MySQL 的扫描行数是通过**索引基数**（cardinality）大致得到并且判断的，而**索引基数**（cardinality）可以通过查询命令` show index from tablename`得到，索引扫描行数的多少就是通过这个值进行判断的。如果较小，就要考虑索引是否有存在的必要的问题了。MySQL 的索引基数并不准确，因为 MySQL 的索引基数是通过采样统计得到的，比如 InnoDb 默认会有 N 个数据页，采样统计会统计这些页面上的不同值得到一个平均值，然后除以这个索引的页面数就得到了这个索引基数。

```
另一个概念叫做索引选择性
索引选择性=索引基数/数据总数，基数可以通过“show index from 表名”查看。
越接近1就越有可能利用索引，也可以理解1为百分百
高索引选择性的好处就是mysql查找匹配的时候可以过滤更多的行，唯一索引的选择性最佳，值为1。

```




### MySQL 是如何判断索引扫描行数的多少？

```
比如一个索引扫描区间是（a,b)

如果a所在的页与b所在的页不多的话，比如说中间隔的页不超过20个，那么会从a所在的页面通过链表的方式遍历到b所在的页面，然后通过访问每个页中保存的记录数的字段，直接算出这个扫描范围内有多少个索引记录条数，这个结果就是索引需要扫描的行数。 

如果a所在的页与b所在的页中间相隔的页数非常多（怎么知道中间有多少页呢，其实是可以访问a的父内节点和b的父内节点，如果碰巧a和b存在同一个父节点，那么可以通过父节点得到a和b中间相隔的页数，如果他们的父节点不是同一个，也可再向上递归，直到找到第一个公共的父节点为止，这一过程是相当快的），当我们知道a和b中间相隔的页数后，可以试着从a开始往前看10个页，这样可以算出平均每个页有的记录数，这个每页记录平均值*相隔的页数后，就可以估算范围记录数
```

```
当查询中出现num in（值1，值2，值3.。。。值n）的时候，加入n的值比较小，是可以做n次的b+数访问并遍历得到一共的需要扫描的索引记录数的，但当n的值非常大，需要访问cardinality（索引列不重复值的个数，innodb给的是一个预估值），再通过系统记录的该表的所有记录数总数（这个对于innodb来说不准确，但有一个预估的值），将总数除以cardinality，就可以得这个索引列上平均每个值重复了多少次，再将该值乘以in （）中的个数，就可以估算出扫描的索引记录数
```



### MySQL 如何指定查询的索引？

在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：

> select * from t force index(index_t)

### 在 MySQL 中指定了查询索引，为什么没有生效？

我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。



### OR查询的失效与否

https://www.cnblogs.com/xiangcaiduoyidian/p/14178332.html

> select * from t where age=10 or num=20;
>
> select * from t where num=10 union select * from t where num=20;
>
> select * from t where num in (10,20);

```
select * from t where num=10 or num=20; 如果num有索引的话，优化器可能会进行index merge 的操作，比如所有num=10的索引记录中，都是以主键的大小进行排序的，对于num=20的情况也一样，这样将num=10所对应的主键和num=20所对应的主键进行合并的操作是比较快的，得到这个id集合后再去回表查询还是会避免一次全表扫描的。
```

那么OR什么情况下会导致索引失效呢？（https://blog.csdn.net/wenniuwuren/article/details/89472136）

```sql
// 走索引。然后mergeIndex
// Using sort_union(index_relationshipi,index_relatedobjid_relatedobjtype_status_isprivate); Using where

explain select * from medicalrecordindexs where relationshipid  = 310361270823  or relatedobjid  =8583359080
```



```sql
// 不走索引，因为第三个isdelete 没有索引，既然没有索引，那么就要全表扫描一次，既然扫描一次，就可以把三个条件的都扫不出开了，而不是前俩走索引后面一个全表扫描

explain select * from medicalrecordindexs where relationshipid  = 310361270823  or relatedobjid  =8583359080 or isdelete=0
```



https://www.jb51.net/article/176651.htm

### 以下查询要如何优化？

表中包含索引：

- KEY mid (mid)
- KEY begintime (begintime)
- KEY dg (day,group)

使用以下 SQL 进行查询：

> select f from t where day='2010-12-31' and group=18 and begintime<'2019-12-31 12:14:28' order by begintime limit 1;

答：此查询理论上是使用 dg 索引效率更高，通过 explain 可以对比查询扫描次数。由于使用了 order by begintime 则使查询放弃了 dg 索引，而使用 begintime 索引，从侧面印证 order by 关键字会影响查询使用索引，这时可以使查询强制使用索引，改为以下SQL：

> select f from t use index(dg) where day='2010-12-31' and group=18 and begintime< '2019-12-31 12:14:28' order by begintime limit 1;

### MySQL 会错选索引吗？

MySQL 会错选索引，比如 k 索引的速度更快，但是 MySQL 并没有使用而是采用了 v 索引，这种就叫错选索引。

```
MySQL的优化器在生成的最终执行计划前，会对各种可能的方式进行分析，需要进行一系列的成本估算，成本估算主要需要考虑io成本和cpu成本，需要访问索引本身的统计数据和表本身的统计数据，而尤其对于innodb而言，这些数据本身就是不准确的，只是一个尽最大努力进行的一个猜测值，如果猜测与实际情况有偏差也会给做决定带来干扰。另外，在做成本分析的时候，在索引范围很大的时候需要估算索引行记录数，尤其当多表连接的时候需要计算扇出值，这里用到了很多估算的方法，这本身也可能带来不准确性。最后，MySQL的设计师利用了很多启发式的，基于经验的算法，从而排除很多情况，但这个也是会跟实际情况有偏差的，尤其是多表连接时，如果有n个表，可能需要分析n！个执行方式的开销，启发式的算法会直接排除一些，综上所述，索引是可能选错的，执行计划不是一定最优化的.
```

### 如何解决 MySQL 错选索引的问题？

- 删除错选的索引，只留下对的索引；
- 使用 force index 指定索引；
- 修改 SQL 查询语句引导 MySQL 使用我们期望的索引，比如把 `order by b limit 1` 改为 `order by b,a limit 1` 语义是相同的，但 MySQL 查询的时候会考虑使用 a 键上的索引。

### 如何优化身份证的索引？

在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：

- 使用身份证倒序存储，这样设置前六位的意义就很大了；
- 使用 hash 值，新创建一个字段用于存储身份证的 hash 值。









