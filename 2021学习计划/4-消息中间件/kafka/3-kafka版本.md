Kafka 是消息引擎系统，也是分布式流处理平台。

Kafka 在设计之初就旨在提供三个方面的特性：

- 提供一套 API 实现生产者和消费者；
- 降低网络传输和磁盘存储开销；
- 实现高伸缩性架构。



KafKa 版本

- Apache Kafka，也称社区版 Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。
- Confluent Kafka，Confluent 公司提供的 Kafka。优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。
- CDH/HDP Kafka，大数据云公司提供的 Kafka，内嵌 Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。



Kafka 服务器端的代码完全由 Scala 语言编写

Kafka_2.11-2.1.1.tgz

前面的版本号是编译 Kafka 源代码的 Scala 编译器版本.

所以2.11是scala的版本号，2.1.1是kafka的版本号

前面的 2 表示大版本号，即 Major Version；中间的 1 表示小版本号或次版本号，即 Minor Version；最后的 1 表示修订版本号，也就是 Patch 号。Kafka 社区在发布 1.0.0 版本后特意写过一篇文章，宣布 Kafka 版本命名规则正式从 4 位演进到 3 位，比如 0.11.0.0 版本就是 4 位版本号。





kafka演进的重要阶段

1. 【0.7 时代演进到 0.8】

```
Kafka 从 0.7 时代演进到 0.8 之后正式引入了副本机制，。有了副本备份机制，Kafka 就能够比较好地做到消息无丢失。
那时候生产和消费消息使用的还是老版本的客户端 API，所谓的老版本是指当你用它们的 API 开发生产者和消费者应用时，你需要指定 ZooKeeper 的地址而非 Broker 的地址。

如果你现在尚不能理解这两者的区别也没关系，我会在专栏的后续文章中详细介绍它们。老版本客户端有很多的问题，特别是生产者 API，它默认使用同步方式发送消息，可以想见其吞吐量一定不会太高。虽然它也支持异步的方式，但实际场景中可能会造成消息的丢失，因此 0.8.2.0 版本社区引入了新版本 Producer API，即需要指定 Broker 地址的 Producer。

据我所知，国内依然有少部分用户在使用 0.8.1.1、0.8.2 版本。我的建议是尽量使用比较新的版本。如果你不能升级大版本，我也建议你至少要升级到 0.8.2.2 这个版本，因为该版本中老版本消费者 API 是比较稳定的。另外即使你升到了 0.8.2.2，也不要使用新版本 Producer API，此时它的 Bug 还非常多。
```

2. 【 0.9.0.0 版本】

```
0.9.0.0 版本,0.9 大版本增加了基础的安全认证 / 权限功能，同时使用 Java 重写了新版本消费者 API

Producer API 在这个版本中算比较稳定了，但是不要使用这个版本的 Consumer API，因为 Bug 超多的，
```

3.【0.10.0.0 是里程碑式的大版本】

```
1.引入了 Kafka Streams

2. 新版本 Consumer API 算是比较稳定了。

3. 如果你依然在使用 0.10 大版本，我强烈建议你至少升级到 0.10.2.2 然后使用新版本 Consumer API。还有个事情不得不提，0.10.2.2 修复了一个可能导致 Producer 性能降低的 Bug。基于性能的缘故你也应该升级到 0.10.2.2。
```

4. 【2017 年 6 月，社区发布了 0.11.0.0 版本】

```
引入了两个重量级的功能变更：
一个是提供幂等性 Producer API 以及事务（Transaction） API；
另一个是对 Kafka 消息格式做了重构
```

5.  Kafka Streams 目前依然还在积极地发展着。如果你是 Kafka Streams 的用户，至少选择 2.0.0 版本吧