##  AMQP 协议

* AMQP 0-9-1（Advanced Message Queuing Protocol）高级消息队列协议是一个消息协议，它支持符合标准的客户端请求程序与符合标准的消息中间件代理进行通信。

![AMQP模型](/Users/jzue/Desktop/AMQP模型.png)

#### 消息代理（message broker）

消息代理会接收来自生产者的消息，并将它们路由（route,可以理解为按照规则转发）给响应的消费者

并且，由于AMQP是一种网络协议，所以消息代理，生产者，消费者，可以分布在不用的机器上



 #### 交换器（Exchange）

生产者生产消息至交换器之后，由交换器负责将消息转发出去。根据交换器类型的不同，交换器将消息转发出去的转发规则也会有所不通过。

AMQP 提供了四种不同的交换器类型：direct ,fanout, topic,header

除此之外，交换器还有许多属性可供设置，其中比较重要的属性有：name,durability，auto-delete,arguments.



（1）默认交换器

不指定交换器类型时，交换器默认是direct类型,其name属性为空。并且默认交换器有一个重要的特性：每个队列都会使用他的队列名字作为路由关键字（routing key） 去自动的绑定到默认的交换器上



换言之，**对于默认的交换器，无需用队列对其进行绑定操作，因为所有的队列都会与之绑定。**



但是，默认交换器与所有队列都进行了绑定并不意味着交换器会将消息分发给所有的队列。交换器最终会将消息转发给哪个队列在生产者生产消息的时候就已经确定了。生产者生产消息时会指定消息路由关键字，这里的路由关键字即队列名。也就是说，**消息会转发给与该路由关键字同名的队列中去**。



（2）direct类型

该类型的交换器在分发消息到指定队列时要求：（生产者生产消息时指定的路由关键字）X,与（队列绑定到交换器时指定的路由关键字）Y  ，一致 即X与Y相等。

而且，多个队列可以使用相同的路由关键字与交换器绑定。比如，生产者不断的生成路由关键字与X的消息，你可以指定多个队列都使用路由关键字Y与该交换器绑定（X=Y），这样一来，消息就会被分发到多个队列中。但是需要注意的是，消息队列的负载均衡并不在队列间，而是在消费者间。



direct 类型的更多内容，请见下文~



（3）fanout类型

该类型的交换器会将消息转发给所有与之绑定的队列上，比如，有N个消息队列与fanout 交换器绑定，当产生一条消息时，交换器会将该消息的N个副本分别发给每个队列。类似于广播机制。



（4）topic 类型

该类型的交换器会视消息路由关键字和绑定路由关键字之间的匹配情况，进行消息转发。

例如：消息路由关键字为x.y.z的消息会转发给关键字为\*.y.\*的队列,也会转发给绑定路由关键字为x.#的队列，但却不会转发给绑定路由关键字为\*.a.\*的队列。



具体的路由关键字的匹配规则将在后面的文章中介绍。



（5）headers类型

该类型的交换器与前面介绍的稍有不同，它不再是基于路由关键字（routing key）进行路由，而是基于多个属性进行路由的，这些属性比路由关键字更容易表示为消息的头。也就是说，用于路由的属性是取自于消息header属性的，当消息header的值与队列绑定时指定的值相同时，消息就会路由至相应的队列中。



#### 队列

队列用来存储消费者待消费的消息，和交换器一样，队列也有许多可供设置的属性，并且除了与交换器一些相同的属性外，还有一些额外的属性。主要的属性有：name,durable,exclusive,auto-delete,arguments等等。



需要注意的是，队列在使用之前必须先声明。声明之前，如果该队列不存在，那么声明之后就会创建一个队列；如果该队列已经存在了，并且声明的队列与存在的队列属性相同，则不产生任何影响；如果该队列已经存在了，但是声明的队列与存在的队列属性不同，则会抛出一个错误码为406（PRECONDITION_FAILED）的异常。

（1）name属性

队列名支持最多255字节的UTF-8字符。应用程序在声明队列的时候可以自己指定队列名，或者当应用程序指定name属性为空时，代理（broker）会自动地为其生成一个唯一的队列名。

需要注意的是，以”amq.”开头的队列名是由AMQP内部使用的命名前缀，请开发者不要使用，否则将抛出403异常。

（2）durability

durability属性对应两种情况，分别是durable（持久的）和transient（短暂的）。durable类型的队列会持久化至硬盘上，所以当代理（broker）重启之后，它依然存在。相反地，当代理重启之后，transient类型的队列就消失了。

需要注意的是，队列的持久化是相对队列而言，对存储在持久化队列中的消息来说，当代理重启之后：队列还存在、消息则不存在。

所以，当broker重启之后，如果想让消息仍然存在，这就是消息持久化机制干的事了，后面再说消息属性的相关内容。



#### 绑定（binding）

​	首先，绑定是队列和交换器之间关系的一个概念。

​	队列获取来自交换器的消息的前提是该队列必须先与交换器进行绑定。绑定之后，交换器才能将消息按照特定的规则，路由至相应的队列中去。随后，消费者才能从队列中消费消息。

​	如果生产者生产的某条消息，没有与之匹配的任何一个队列可供路由（比如，没有任何队列与交换器绑定）。那么，根据该条消息的属性，该消息要么丢弃，要么返回至生产者。



#### 连接（connection）

我们已经知道，AMQP是一个应用层协议，并且是基于TCP可靠传输的应用层协议。

除此之外，AMQP也提供了加密传输的机制（TSL,SSL）,让消息的传递更安全。



当需要断开AMQP代理时，正确的做法是关闭AMQP连接，而不是粗鲁的直接断开其底层的TCP连接。



#### 通道（channel）

有的应用程序需要与AMQP broker建立多个连接。在AMQP模型中，我们不需要通过建立太多的TCP连接来实现。假如针对每一个AMQP连接都建立一个TCP连接的话，会占用大量的系统资源。对此，AMQP提供了通道（channel）机制。即，共享一个TCP连接，可创建多个通道。



在多线程/进程的应用程序中正确做法是，对于每一个线程/进程，应分别建立一个通道，而不是多个线程/进程之间去共享一个通道。



#### 虚拟机（virtual hosts）

AMQP使用了虚拟机的盖帘，在一个broker上面划分出多个隔离的环境（各环境下的用户、交换器以及队列等互不影响）。这样一来，AMQP客户端们再进行连接的时候，需要协商指定的一个vhost才能进行正常的业务。



#### 消息确认（message acknowledgements）



