在不抛异常的情况下try catch影响性能极小。

理由是在没有抛出异常时，try catch的影响跟添加了一个 if else是同一个量级的。也就是说，我们完全可以忽视try catch耗费的那点性能。1、异常如果没发生，也就不会去查表，也就是说你写不写try catch 也就是有没有这 个异常表的问题，如果没有发生异常，写try catch对性能是木有消耗的，所以不会让程序跑得更慢。2、try 的范围大小其实就是异常表中两个值（开始地址和结束地址）的差异而已，也是不会影响性能的。



在抛异常的情况下try catch 内存影响很大。

异常开销很大，当创建一个异常时，需要收集一个栈跟踪（stack track），这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。运行时栈不是为有效的异常创建而设计的，而是设计用来让运行时尽可能快地运行。入栈，出栈，入栈，出栈。让这样的工作顺利完成，而没有任何不必要的延迟。但是，当需要创建一个Exception 时，JVM不得不说：“先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作，笑着等我拍完快照吧。”栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素，从栈顶到栈底，还有行号和一切应有的东西。如果在一个深度为20的栈中创建了异常，那么就别指望只记录顶部的几个栈元素了――您得完完整整地记录下所有20个元素。从 main 或Thread.run （在栈底）到栈顶，记录整个栈。因此，创建异常这一部分开销很大。从技术上讲，栈跟踪快照是在本地方法 Throwable.fillInStackTrace() 中发生的，这个方法又是从 Throwable contructor 那里调用的。但是这并没有什么影响――如果您创建一个 Exception ，就得付出代价。