## 概念

* Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得

* Semaphore 实现了信号量，概念上讲，一个信号量相当于持有一些许可（permits），线程可以调用Semaphore对象的acquire())方法获取一个许可，调用release()来归还一个许可

* 信号量一般用来限制访问资源数量

* 单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合


## (单)Semaphore与互斥锁(互斥量)

### 区别   [参考文章]()

* **作用域不同**：信号量-进程或线程；互斥锁-线程间

* **互斥量用于线程的互斥，信号量用于线程的同步。**

  这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

  互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

  同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源

* **互斥量值只能为0/1，信号量值可以为非负整数。**

  也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。

* **互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。**





## (多)Semaphore 与线程池

### 区别     [参考文章](https://blog.csdn.net/mryang125/article/details/81490783)

* 线程池控制的是线程数量，信号量控制的是并发数量
* 信号量的调用，当达到数量后，线程还是存在的，只是被挂起了；而线程池，同时执行的线程数是固定的，达到数量以后就只有等待———>  

更直白朴素的说，就是信号量的调用，在达到数量以后，其他线程只是在排队，等待执行任务；而线程池的则是分配给你固定数量的线程执行任务，从头到尾都是分配给你的固定数量的这几个线程在替你工作。























