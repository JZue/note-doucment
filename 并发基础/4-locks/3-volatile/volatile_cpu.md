首先明确，现代的CPU的三级缓存一般是分行存储的，最小处理单位是一个行，这个行的长度一般来说就是上文提到的64字节。

为什么要分行？

```
缓存虽然小，但是也不是太小，CPU在加载主存数据时，如果一次性将整个Cache填满，但是接下来的指令访问的数据又不在缓存上，就会导致读浪费。另外如果只修改了其中几个字节的数据，但是得回写整个Cache到内存，这又会导致写浪费
```



#### 内存语义

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中(把L1,L2缓存刷新的L3上)。

当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量（直接从L3缓存读数据）。

#### 伪共享

多个线程同时读写同一个缓存行不同变量时，尽管这些变量之间没有任何关系，但是多个线程之间仍然需要同步，从而导致性能下降的情况。

![参考图1]![img](https://img-blog.csdnimg.cn/2019012213561760.png)







对于单核处理器，cpu处理共享数据时，会





对于单核cpu volatile关键字的可见性的特性是没有意义了











[参考1](https://www.zhihu.com/question/63120810)