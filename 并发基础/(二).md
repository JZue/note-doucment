![](/Users/jzue/Downloads/Java并发课程资料/课程资料/相关图例/4.jpg)

### 为什么会需要CPU Cache 

cpu的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费时间。所以Cache的出现，是为了缓解CPU和内存之间的速度不匹配的问题（cpu>cache>memory）



1)   时间局部性：如果某个数据被访问，那么不久的将来他很有可能会再次被访问。

2）空间局部性：如果某个数据被访问，那么与他相邻的数据也很有可能会被访问



### 缓存一致性

### 乱序执行优化

处理器为提高运算速度而做出的违背代码原有顺序的优化

在单核环境下是没有问题的，但是在多核环境下就会出现问题。



### JVM 内存模型（JMM）

![](/Users/jzue/Downloads/Java并发课程资料/课程资料/相关图例/5.jpg)

java内存模型它规定了如何和何时可以看到被其他线程修改后的共享变量的值，以及在必要时，如何同步的访问共享变量。



### JMM抽象结构图

![](/Users/jzue/Downloads/Java并发课程资料/课程资料/相关图例/8.jpg)

### JMM -同步操作和规则

下面是内存模型的八个操作lock->read->load->use->assign->store->write->unlock

然后对应的规则：

1）一个变量同一时间，只允许一个线程对其使用lock操作，但是可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock才可以被解锁

2）read/load、store/write 这两组必须一起出现，并且必须按顺序执行，但是不要求连续执行

3）变量在工作内存中assign以后必须把变化的变量同步到主内存

4）不允许未经assign操作，就将变量从工作内存同步到主内存

5）新变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量

6) 如果对一个变量执行的lock操作，那么会清楚工作内存中的其的值，在执行引擎使用其之前，必须重新执行load或者assign的操作，来拿到他初始化的值

7）当前线程不允许对其他线程执行unlock操作

8）unlock之前必须把值先同步到主内存

![9](/Users/jzue/Downloads/Java并发课程资料/课程资料/相关图例/9.jpg)