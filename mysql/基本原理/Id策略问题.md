## 主键的生成策略以及优劣

#### 自增主键

* 优：实现简单，节省时间，数字型占空间小，易排序
* 劣：
  - 不具有连续性，会存在删除中间某条数据就会跳号的情况。
  - 如果有合并表的需求，会有id冲突问题（一般采用自增幅度来解决），得对未来业务有足够的规划，不然后期维护会有很多问题。
  - 自增锁(AUTO_INC锁)，表里有一个auto_increment字段的时候，innoDB会在内存里保存一个计数器用来记录auto_increment的值，当插入一个新行数据时，就会用一个表锁来锁住这个计数器，直到插入结束。如果大量的并发插入，表锁会引起SQL堵塞。

#### UUID

* 优：没有自增锁的问题，没有合并表的id冲突问题，实现简单
* 劣
  - UUID非常长，占空间，最主要的问题在索引上，在建立索引和基于索引进行查询时都存在性能问题

#### 自己维护一个Sequence表

* 每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用
* 优：没有自增锁问题…….视具体情况而定
* 劣：
  - 由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。

#### twitter的snowflake算法

介绍：分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。

有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。

snowflake的结构如下(每部分用-分开):

0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000

第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号），一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)。

snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。经测试snowflake每秒能够产生26万个ID。



#### 甚至用redis的 incr也完全可以实现唯一id的自增。

但是这样的强关联~一旦redis集群有问题，可能整个平台都用不了了。



#### 总结

​	主要针对MySQL数据库中的InnoDB存储引擎的主键设计原则进行调研，挑选了几种主流的主键方案进行优缺点的分析和对比。

​	 如果一些特殊的表，比如说日志表，其不需要维护，可以采用数据库自动增长ID的方式。这种方式性能好，产生也很方便。但是维护很麻烦。

​	

一般情况：UUID--------------------------------适合小规模的分布式环境

​		  自增ID+自增幅度-----------------适合中等规模的分布式场景

​		  twitter的snowflake算法-------适合大数据环境的分布式场景

​	           







