#### 什么是索引

索引定义：索引是一种排序和快速查找的数据结构。

索引对where （where condition）和order by (field)  还有group by【 条件筛选和排序查找】起作用

del_flag可以保持索引连续性

update慢也可能是索引过多导致的

mysql中支持hash和btree索引。**innodb和myisam只支持btree索引**（这一点很关键，毕竟现在大家最常用的应该就是innodb），而memory和heap存储引擎可以支持hash和btree索引

#### 索引算法

MyISAM是[MySQL](http://lib.csdn.net/base/mysql) 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。

MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。

InnoDB中非主键索引使用的是B-Tree[数据结构](http://lib.csdn.net/base/datastructure)，而主键索引使用的是B+Tree。

关于btree索引的数据结构：<https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html>

b-tree(-不是减号，是横杠),b+tree算法，不说要达到可以实现，至少得知道是啥玩意。

友情提示：记不住算法是啥玩意的最好办法就是把它实现几遍就可以了，Talk is cheap,show me the code  [/滑稽]

#### 什么情况下适合建索引，哪些情况不适合建索引

* 经常增删改的字段,不优先考虑索引
* 数据量比较少
* 如果某个数据列包含很多重复内容，就没必要建
  * 例如：加入一个表有300万行记录，有一个字段A只有ture和false 两个值，且每个值的分布概率大约50%，那么对A建索引一般不会提交高数据库的查询速度
  * 索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表有200万条记录，表索引列有190万种情况，那么选择性就是190/200=95%,一个索引的选择性越接近1.那么效率就越高

#### 为什么重复率高就没必要建索引

​	首先我们得明白，我们平时用的索引都叫**非聚集索引**，这时候，如果你select 的字段如果就在字段内，就会用到**覆盖索引**，如果你select 的字段不在索引中，那么通过非聚集索引查到的是记录对应的主键值，然后再使用主键的值查找需要的数据

​	这个时候再来理解，为什么重复多的没必要建索引

​	非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引，再获取select字段值，如果这个时候重复率很高，就会大量的跳到主键索引的动作，反而还会降低性能

​	

#### 聚集索引和非聚集索引

* 聚集索引 
  * 主键就是聚集索引
  * 表记录的排列顺序和与索引的排列顺序一致
  * 一张表只能有唯一的一个聚集索引
  * 实际上总结一下就是可以理解为主键
* 非聚集索引（也叫辅助索引）
  * 包括**单字段索引**和多字段索引（**联合索引**），即常规索引
  * 给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联
  * 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间
  * 非聚集索引又分**唯一非聚集索引（唯一索引）**和**非唯一非聚集索引（非唯一索引）**两种，这同样是依据业务逻辑而定的，**唯一非聚集索引指的是一个由多个业务字段组成的索引**，在业务逻辑上是唯一的，**反之就是非唯一的非聚集索引**。比如“中国+身份证号”，这就是一个唯一索引，因为中国的每个身份证号理论上都是唯一的。而“中国+姓名”则是一个非聚集索引，因为中国又很多重名的人。
* 聚集索引和非聚集索引区别
  * 聚集索引可以查到需要查找的数据
  * 通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据

#### 什么是覆盖索引

​	上面的解释中提到了覆盖索引，什么是覆盖索引呢？

​	select的字段列正好就在索引中存在，直接就可以从索引中取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖

#### 索引的性能分析

* MySQL Query Optimizer(查询优化器)：
* 常见瓶颈
  * CPU
  * IO
  * 配置或者硬件（例如缓冲区设置小了）
* explain +sql
* show profiles





